# 第 3 章 运算符

## Section 3.1：运算符优先级和方法

| 运算符 | 说明 | 是否是方法？ |
| --- | --- | --- |
| . | 方法调用 | ✔️ |
| []  []= | 方括号查找、括号组 |  |
| ! ~ + | 布尔非、补码、一元加号 |  |
| ** | 幂运算 |  |
| - | 一元减 |  |
| * / % | 乘、除、取模 |  |
| + - | 加、减 |  |
|  |  |  |
| < > | 按位移位 |  |
| & | 按位与 |  |
| | ^ | 按位或、按位异或 |  |
| < ≤ ≥ > | 比较 |  |
| ≤>  == ≠  === =~ !~ | 等于、正则匹配、比较 |  |
| && | 布尔与 |  |
| || | 布尔或 |  |
| .. ... | 包含范围、不包含范围 |  |
| ? : | 三元运算 |  |
| rescue |  |  |
| = += -= | 赋值 |  |
| defined? | 定义运算符 |  |
| not | 布尔not |  |
| or and | 布尔or、布尔and |  |
| if unless while until | 条件if、unless、while、until |  |
| { } | 块 |  |
| do end | 块do...end |  |


```ruby
"123.50".to_f #=> 123.5
Float("123.50") #=> 123.5
```

尽管上述结果相同，但当字符串不是一个有效的浮点型存在差别

```ruby
"something".to_f #=> 0.0
Float("something") #=> ArgumentError: invalid value for Float(): "something"
```

## 3.2 节 转字符串

```ruby
123.5.to_s #=> "123.5"
String(123.5) #=> "123.5"
```

通常，`String()` 只是调用 `#to_s`

`Kernel#sprintf` 和 `String#%` 和 C 语言中的类似

```ruby
sprintf("%s", 123.5) #=> "123.5"
"%s" % 123.5 #=> "123.5"
"%d" % 123.5 #=> "123.5"
"%.2f" % 123.5 #=> "123.50"
```

## 3.3 节 转整数

```ruby
"123.50".to_i #=> 123
Integer("123.50").to_i #=> 123
```

字符换转整型时，只会从字符串开头处开始转整型，不会从字符串其他部分取整数值

```ruby
"123-foo".to_i #=> 123
"foo-123".to_i #=> 0
```

当字符串不是一个有效的整数时，会有以下区别

```ruby
"something".to_i #=> 0
Integer("something") #=> ArgumentError: invalid value of Integer(): "something"
```

3.4 节 浮点型和整数互转

```ruby
1/2 #=> 0
```

	因为做除法的时候用的是两个整数， 所以结果也应该是一个整数。为了解决这个问题，至少要把一个数转换成浮点型

```ruby
1.0/2 #=> 0.5
1.to_f / 2 #=> 0.5
1/Float(2) #=> 0.5
```

或者，使用 `fdiv` 来返回浮点型的除法结果， 使用它时不需要再做额外的转换。

```ruby
1.fdiv 2 #=> 0.5
```